--집합연산자
--UNION == 합집합(중복X)
--UNION ALL = 합집합(중복O)
--INTERSECT
--MINUS

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%' 
UNION 
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%' 
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%' 
INTERSECT --교집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%' 
MINUS --빼기
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL 은 가상테이블을 만들 때 사용이 가능합니다.

SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES
UNION ALL
SELECT 200, 'HONGKILDONG' FROM DUAL
UNION ALL
SELECT 300, 'DD'FROM DUAL
UNION ALL
SELECT 400, 'PARK'FROM DUAL;

--시험단골문제라서 기억하기
--분석함수
SELECT EMPLOYEE_ID,
        FIRST_NAME,
        SALARY,
        RANK() OVER(ORDER BY SALARY DESC)AS 중복등수,-- 분석함수는 OVER(조건)과 반드시 함께 사용됩니다
        DENSE_RANK() OVER(ORDER BY SALARY DESC)AS 중복없는등수,
        ROW_NUMBER() OVER(ORDER BY SALARY ASC) AS 일련번호
FROM EMPLOYEES;

--ROWNUM과의 차이 -- ROWNUM은 ORDER BY 시에 결과가 바뀝니다
SELECT ROWNUM  EMPLOYEES_ID, FIRST_NAME,SALARY
FROM EMPLOYEES
ORDER BY SALARY ;